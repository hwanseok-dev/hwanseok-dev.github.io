---
title: "[BOJ][실1][1068] 트리"
excerpt: ""
date: 2021-01-10
last_modified_at:
categories:
  - Algorithm-Practice
tags:
  - Algorithm-Practice
  - Practice
  - Implementation
  - DFS
  - 깊이우선탐색
  - "1068"
  - 친구
toc : true
toc_label: "Table of contents"
toc_icon: "list"  # corresponding Font Awesome icon name (without fa prefix)
toc_sticky: true
---

## 문제 링크

[문제링크](boj.kr/1068)  

## 첫 번째 풀이 : DFS

### 알고리즘

먼저 트리 정보를 인접리스트로 저장합니다. 

v[i] : i의 child 리스트  

각 노드의 인접리스트의 길이가 0이라면 리프노드라는 뜻입니다. 그리고 지울 노드에서 dfs를 시작해서 리프 노드에 도달했을 때 리프노드를 하나 지웁니다. 추가적으로 지운 노드의 부모 노드가 지운 노드에 의해서 리프노드가 되는지 판단해서 +1까지 해줍니다.    

### 정답 코드

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

vector<int> v[50];
bool visited[50];
int ans = 0;
int tans = 0;

void dfs(int x, int depth) {
  if (!visited[x]) {
    visited[x] = true;
    tans++;
  }
  if (depth == 2) {
    return;
  }

  for (int i = 0; i < v[x].size(); i++) {
    int next = v[x][i];
    dfs(next, depth + 1);
  }
}

int main()
{
  //freopen("input.txt", "r", stdin);
  ios_base::sync_with_stdio(0); cin.tie(0);
  int n; cin >> n;
  char c;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      cin >> c;
      if (c == 'Y') {
        v[i].push_back(j);
      }
    }
  }

  for (int i = 0; i < n; i++) {
    tans = 0;
    memset(visited, false, sizeof(visited));
    dfs(i, 0);
    ans = max(ans, tans);
  }
  cout << ans - 1 << "\n";

  return 0;
}
```

## 두 번째 풀이

### 알고리즘

그래프를 문제에서 주어진 그대로, 각 노드의 부모 노드 번호를 저장하는 형태로 사용합니다.  

추가적인 설명은 주석으로 남겨놨습니다.  

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int n;
int p[50]; // parent number
int c[50]; // # of child

// 현재 노드를 지운다
void dfs(int x) {
  // 부모의 자식을 1개 줄인다
  if (p[x] != -1) {
    c[p[x]]--;
  }
  // 현재 노드의 부모를 없애기
  c[x] = -1;
  
  // 자식노드도 같은 과정 반복하기
  for (int i = 0; i < n; i++) {
    if (p[i] == x) {
      dfs(i);
    }
  }

}

int main()
{
  //freopen("input.txt", "r", stdin);
  ios_base::sync_with_stdio(0); cin.tie(0);
  cin >> n;
  for (int i = 0; i < n; i++) {
    cin >> p[i];
    if (p[i] != -1) {
      c[p[i]]++; // 부모가 가지는 자식의 갯수 + 1
    }
  }
  int d = 0;
  cin >> d;
  dfs(d);
  int ans = 0;
  for (int i = 0; i < n; i++) {
    if (c[i] == 0) ans++;
  }
  cout << ans;

  return 0;
}
```


**Success Notice:**
수고하셨습니다. :+1:
{: .notice--success}


